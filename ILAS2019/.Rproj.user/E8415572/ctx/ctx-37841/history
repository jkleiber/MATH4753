points(xy[1],xy[2],cex=2,pch=21,bg="Blue")
title("Practical demonstration of unbiased estimators")
numerator = ifelse(nadj==1, n,n-1)
text(mu,sigma^2, substitute(plain(E)*(S^2)==frac(numerator,n)*sigma^2,list(numerator=numerator,n=n)))
}
bullseye()
#' @param iter Number of iterations
#' @param mu Population mean
#' @param sigma Population standard deviation
#' @param nadj Adjuctment to `n`
#'
#' @return Plots a bull's eye target
#' @export
#'
#' @examples
#' bulleseye()
bullseye<-function(n=30,iter=10000,mu=10,sigma=10, nadj=1){
graphics.off()
xbar=rnorm(iter,mean=mu,sd=sigma/sqrt(n))
ssq=sigma^2*rchisq(iter,n-1)/(n-nadj)# adjsut the n
df = data.frame(xbar = xbar,ssq =ssq)
windows()
plot(ssq~xbar,pch=21,bg=rgb(0,1,0,0.5),cex=0.7,
xlab=expression(bar(x)),
ylab=expression(s^2),
col="Grey")
leg.txt = c(expression(paste(mu,",",sigma^2)),expression(paste(bar(bar(x)),",",bar(s^2))))
legend("topright", leg.txt,
fill=c("Red","Blue") )
abline(v=mu,h=sigma^2, lwd=4, col="Red") # pop
xy=colMeans(df)
abline(v=xy[1],h=xy[2], lwd = 2, col = "Blue") # sample
points(mu,sigma^2,cex =4, pch=21,bg = "Black")
points(mu,0.8*sigma^2,cex =2, pch=21,bg = "Pink")
points(xy[1],xy[2],cex=2,pch=21,bg="Blue")
title("Practical demonstration of unbiased estimators")
numerator = ifelse(nadj==1, n,n-1)
text(mu,sigma^2, substitute(plain(E)*(S^2)==frac(numerator,n)*sigma^2,list(numerator=numerator,n=n)))
}
bullseye()
#' @param iter Number of iterations
#' @param mu Population mean
#' @param sigma Population standard deviation
#' @param nadj Adjuctment to `n`
#'
#' @return Plots a bull's eye target
#' @export
#'
#' @examples
#' bulleseye()
bullseye<-function(n=30,iter=10000,mu=10,sigma=10, nadj=1){
graphics.off()
xbar=rnorm(iter,mean=mu,sd=sigma/sqrt(n))
ssq=sigma^2*rchisq(iter,n-1)/(n-nadj)# adjsut the n
df = data.frame(xbar = xbar,ssq =ssq)
windows()
plot(ssq~xbar,pch=21,bg=rgb(0,1,0,0.5),cex=0.7,
xlab=expression(bar(x)),
ylab=expression(s^2),
col="Grey")
leg.txt = c(expression(paste(mu,",",sigma^2)),expression(paste(bar(bar(x)),",",bar(s^2))))
legend("topright", leg.txt,
fill=c("Red","Blue") )
abline(v=mu,h=sigma^2, lwd=4, col="Red") # pop
xy=colMeans(df)
abline(v=xy[1],h=xy[2], lwd = 2, col = "Blue") # sample
points(mu,sigma^2,cex =4, pch=21,bg = "Black")
points(mu,sigma^2,cex =2, pch=21,bg = "Pink")
points(xy[1],xy[2],cex=2,pch=21,bg="Blue")
title("Practical demonstration of unbiased estimators")
numerator = ifelse(nadj==1, n,n-1)
text(mu,0.8*sigma^2, substitute(plain(E)*(S^2)==frac(numerator,n)*sigma^2,list(numerator=numerator,n=n)))
}
bullseye()
bullseye(nadj=1)
bullseye(nadj=0)
mvmat=function(sig11=100,sig22=400,sig12=100){
sig21=sig12
library(mvtnorm)
sig=matrix(c(sig11,sig12,sig21,sig22),nr=2,nc=2,byrow=TRUE)
mat=rmvnorm(100,mean=c(10,10),sigma=sig)
mat=mat-apply(mat,2,mean) # zero the means
x1=mat[,1]
x2=mat[,2]
mat
s11=sd(x2)
s22=sd(x1)
s12=cov(x1,x2)
windows()
plot(x2~x1, main="MV Normal points\n Wayne Stewart", xlim=c(0-3*sqrt(s11),0+3*sqrt(s11)), ylim=c(0-3*sqrt(s22),0+3*sqrt(s22)),las=1)
#Task 3
n=dim(mat)[1]
covx=(n-1)/n*cov(mat)
library(ellipse)
#help(package="ellipse")
pts=ellipse(covx,centre=c(0,0))
points(pts,type="l", col="Blue", lwd=2)
abline(v=0,h=0)
}
mvmat=function(sig11=100,sig22=400,sig12=100){
sig21=sig12
library(mvtnorm)
sig=matrix(c(sig11,sig12,sig21,sig22),nr=2,nc=2,byrow=TRUE)
mat=rmvnorm(100,mean=c(10,10),sigma=sig)
mat=mat-apply(mat,2,mean) # zero the means
x1=mat[,1]
x2=mat[,2]
mat
s11=sd(x2)
s22=sd(x1)
s12=cov(x1,x2)
windows()
plot(x2~x1, main="MV Normal points\n Wayne Stewart", xlim=c(0-3*sqrt(s11),0+3*sqrt(s11)), ylim=c(0-3*sqrt(s22),0+3*sqrt(s22)),las=1)
#Task 3
n=dim(mat)[1]
covx=(n-1)/n*cov(mat)
library(ellipse)
#help(package="ellipse")
pts=ellipse(covx,centre=c(0,0))
points(pts,type="l", col="Blue", lwd=2)
abline(v=0,h=0)
}
mvmat()
mvmat=function(sig11=100,sig22=400,sig12=100){
sig21=sig12
library(mvtnorm)
sig=matrix(c(sig11,sig12,sig21,sig22),nr=2,nc=2,byrow=TRUE)
mat=rmvnorm(100,mean=c(10,10),sigma=sig)
mat=mat-apply(mat,2,mean) # zero the means
x1=mat[,1]
x2=mat[,2]
mat
s11=sd(x2)
s22=sd(x1)
s12=cov(x1,x2)
windows()
plot(x2~x1, main="MV Normal points\n Wayne Stewart", xlim=c(0-5*sqrt(s11),0+5*sqrt(s11)), ylim=c(0-5*sqrt(s22),0+5*sqrt(s22)),las=1)
#Task 3
n=dim(mat)[1]
covx=(n-1)/n*cov(mat)
library(ellipse)
#help(package="ellipse")
pts=ellipse(covx,centre=c(0,0))
points(pts,type="l", col="Blue", lwd=2)
abline(v=0,h=0)
}
mvmat()
mvmat=function(sig11=100,sig22=400,sig12=100,rangxy=10){
sig21=sig12
library(mvtnorm)
sig=matrix(c(sig11,sig12,sig21,sig22),nr=2,nc=2,byrow=TRUE)
mat=rmvnorm(100,mean=c(10,10),sigma=sig)
mat=mat-apply(mat,2,mean) # zero the means
x1=mat[,1]
x2=mat[,2]
mat
s11=sd(x2)
s22=sd(x1)
s12=cov(x1,x2)
windows()
plot(x2~x1, main="MV Normal points\n Wayne Stewart", xlim=c(0-rangxy*sqrt(s11),0+rangxy*sqrt(s11)), ylim=c(0-rangxy*sqrt(s22),0+rangxy*sqrt(s22)),las=1)
#Task 3
n=dim(mat)[1]
covx=(n-1)/n*cov(mat)
library(ellipse)
#help(package="ellipse")
pts=ellipse(covx,centre=c(0,0))
points(pts,type="l", col="Blue", lwd=2)
abline(v=0,h=0)
}
mvmat(rangxy = 10)
mvmat(rangxy = 20)
mvmat=function(sig11=100,sig22=400,sig12=100,rangxy=15){
sig21=sig12
library(mvtnorm)
sig=matrix(c(sig11,sig12,sig21,sig22),nr=2,nc=2,byrow=TRUE)
mat=rmvnorm(100,mean=c(10,10),sigma=sig)
mat=mat-apply(mat,2,mean) # zero the means
x1=mat[,1]
x2=mat[,2]
mat
s11=sd(x2)
s22=sd(x1)
s12=cov(x1,x2)
windows()
plot(x2~x1, main="MV Normal points\n Wayne Stewart", xlim=c(0-rangxy*sqrt(s11),0+rangxy*sqrt(s11)), ylim=c(0-rangxy*sqrt(s22),0+rangxy*sqrt(s22)),las=1)
#Task 3
n=dim(mat)[1]
covx=(n-1)/n*cov(mat)
library(ellipse)
#help(package="ellipse")
pts=ellipse(covx,centre=c(0,0))
points(pts,type="l", col="Blue", lwd=2)
abline(v=0,h=0)
}
mvmat()
mvmat=function(sig11=100,sig22=400,sig12=100,rangxy=15){
sig21=sig12
library(mvtnorm)
sig=matrix(c(sig11,sig12,sig21,sig22),nr=2,nc=2,byrow=TRUE)
mat=rmvnorm(100,mean=c(10,10),sigma=sig)
mat=mat-apply(mat,2,mean) # zero the means
x1=mat[,1]
x2=mat[,2]
mat
s11=sd(x2)
s22=sd(x1)
s12=cov(x1,x2)
windows()
plot(x2~x1, main="MV Normal points\n Wayne Stewart", xlim=c(0-rangxy*sqrt(s11),0+rangxy*sqrt(s11)), ylim=c(0-rangxy*sqrt(s22),0+rangxy*sqrt(s22)),las=1)
#Task 3
n=dim(mat)[1]
covx=(n-1)/n*cov(mat)
library(ellipse)
#help(package="ellipse")
pts=ellipse(covx,centre=c(0,0))
points(pts,type="l", col="Blue", lwd=2)
abline(v=0,h=0)
invisible(list(mat=mat))
}
mvmat=function(sig11=100,sig22=400,sig12=100,rangxy=15){
sig21=sig12
library(mvtnorm)
sig=matrix(c(sig11,sig12,sig21,sig22),nr=2,nc=2,byrow=TRUE)
mat=rmvnorm(100,mean=c(10,10),sigma=sig)
mat=mat-apply(mat,2,mean) # zero the means
x1=mat[,1]
x2=mat[,2]
s11=sd(x2)
s22=sd(x1)
s12=cov(x1,x2)
windows()
plot(x2~x1, main="MV Normal points\n Wayne Stewart", xlim=c(0-rangxy*sqrt(s11),0+rangxy*sqrt(s11)), ylim=c(0-rangxy*sqrt(s22),0+rangxy*sqrt(s22)),las=1)
#Task 3
n=dim(mat)[1]
covx=(n-1)/n*cov(mat)
library(ellipse)
#help(package="ellipse")
pts=ellipse(covx,centre=c(0,0))
points(pts,type="l", col="Blue", lwd=2)
abline(v=0,h=0)
invisible(list(mat=mat))
}
mvmat()
help(package="mvtnorm")
mynewt=function(x0,f=myfun,delta=1e-12,epsilon=1e-12,th1=c(0,2*pi),th2=c(0,pi/2),parameter=expression(theta))
{
graphics.off()  # Kill all graphics windows
old.par=par()
options(digits=12)
# x0 initial value
#f the function to be zeroed
#delta is the increment in the derivative
#epsilon is how close our approximation is to zero
#th1 is the range of rotation angle for NR
#th2 is the range for rotation angle for myfun
fdash=function(x) (f(x+delta)-f(x))/delta
d=1000 # initial values
i=0
x=c() # empty vectors
y=c()
x[1]=x0 # assign initial guess
y[1]=f(x[1]) # initial y value
while(d > epsilon & i<100){ # ensures that it doesnt loop too much
i=i+1
x[i+1]=x[i]-f(x[i])/fdash(x[i]) # NR step
y[i+1]=f(x[i+1]) # update y value
d=abs(y[i+1]) # update d
}
windows()
#Cut the graphical area into two
layout(matrix(1:2,nr=2,nc=1,byrow=TRUE),heights=c(3,4))
curve(f(x), xlim=th1,xlab=parameter,ylab="f",main="myfun")
abline(h=0,col="Red",lwd=2)
# plot f with no x axis  on a reduced x range
curve(f(x),xlim=th2,xaxt="n", xlab=parameter,ylab="f",main=  "Newton-Raphson Algorithm")
points(x,y,col="Red",pch=19,cex=0.5)
# Now plot the x axis
axis(1,x,round(x,2),las=2)
abline(h=0,col="Red")
# Make blue segments to represent the tangents
#make green segments for y values
segments(x[1:(i-1)],y[1:(i-1)],x[2:i],rep(0,i-1),col="Blue",lwd=0.5)
segments(x[2:i],rep(0,i-1),x[2:i],y[2:i],lwd=0.5,col="Green")
# paste the root onto the last graph
arrows(x0=x[i+1],y0=y[1],x1=x[i+1],y1=y[i+1])
text(x[i+1],y[1],x[i+1])
return(list(x=x,y=y,d=d,root=x[i+1]))
par(old.par)
}
root=my.newt(1.0,th2=c(1,1.4))$root
s12=100
s11=200
s22=400
#Test the answer in two ways
myfun(root)
# s12 tilde
myfun=function(x) (s22-s11)*sin(x)*cos(x) +s12*(cos(x)^2-sin(x)^2)
mynewt=function(x0,f=myfun,delta=1e-12,epsilon=1e-12,th1=c(0,2*pi),th2=c(0,pi/2),parameter=expression(theta))
{
graphics.off()  # Kill all graphics windows
old.par=par()
options(digits=12)
# x0 initial value
#f the function to be zeroed
#delta is the increment in the derivative
#epsilon is how close our approximation is to zero
#th1 is the range of rotation angle for NR
#th2 is the range for rotation angle for myfun
fdash=function(x) (f(x+delta)-f(x))/delta
d=1000 # initial values
i=0
x=c() # empty vectors
y=c()
x[1]=x0 # assign initial guess
y[1]=f(x[1]) # initial y value
while(d > epsilon & i<100){ # ensures that it doesnt loop too much
i=i+1
x[i+1]=x[i]-f(x[i])/fdash(x[i]) # NR step
y[i+1]=f(x[i+1]) # update y value
d=abs(y[i+1]) # update d
}
windows()
#Cut the graphical area into two
layout(matrix(1:2,nr=2,nc=1,byrow=TRUE),heights=c(3,4))
curve(f(x), xlim=th1,xlab=parameter,ylab="f",main="myfun")
abline(h=0,col="Red",lwd=2)
# plot f with no x axis  on a reduced x range
curve(f(x),xlim=th2,xaxt="n", xlab=parameter,ylab="f",main=  "Newton-Raphson Algorithm")
points(x,y,col="Red",pch=19,cex=0.5)
# Now plot the x axis
axis(1,x,round(x,2),las=2)
abline(h=0,col="Red")
# Make blue segments to represent the tangents
#make green segments for y values
segments(x[1:(i-1)],y[1:(i-1)],x[2:i],rep(0,i-1),col="Blue",lwd=0.5)
segments(x[2:i],rep(0,i-1),x[2:i],y[2:i],lwd=0.5,col="Green")
# paste the root onto the last graph
arrows(x0=x[i+1],y0=y[1],x1=x[i+1],y1=y[i+1])
text(x[i+1],y[1],x[i+1])
return(list(x=x,y=y,d=d,root=x[i+1]))
par(old.par)
}
mynewt()
root=mynewt(1.0,th2=c(1,1.4))$root
#Test the answer in two ways
myfun(root)
#' @return
#' @export
#'
#' @examples
#' root=mynewt(1.0,th2=c(1,1.4))$root
#' s12=100
#' s11=200
#' s22=400
#' #Test the answer in two ways
#' myfun(root)
mynewt=function(x0,f=myfun,delta=1e-12,epsilon=1e-12,th1=c(0,2*pi),th2=c(0,pi/2),parameter=expression(theta))
{
graphics.off()  # Kill all graphics windows
old.par=par()
options(digits=12)
# x0 initial value
#f the function to be zeroed
#delta is the increment in the derivative
#epsilon is how close our approximation is to zero
#th1 is the range of rotation angle for NR
#th2 is the range for rotation angle for myfun
fdash=function(x) (f(x+delta/2)-f(x-delta/2))/delta
d=1000 # initial values
i=0
x=c() # empty vectors
y=c()
x[1]=x0 # assign initial guess
y[1]=f(x[1]) # initial y value
while(d > epsilon & i<100){ # ensures that it doesnt loop too much
i=i+1
x[i+1]=x[i]-f(x[i])/fdash(x[i]) # NR step
y[i+1]=f(x[i+1]) # update y value
d=abs(y[i+1]) # update d
}
windows()
#Cut the graphical area into two
layout(matrix(1:2,nr=2,nc=1,byrow=TRUE),heights=c(3,4))
curve(f(x), xlim=th1,xlab=parameter,ylab="f",main="myfun")
abline(h=0,col="Red",lwd=2)
# plot f with no x axis  on a reduced x range
curve(f(x),xlim=th2,xaxt="n", xlab=parameter,ylab="f",main=  "Newton-Raphson Algorithm")
points(x,y,col="Red",pch=19,cex=0.5)
# Now plot the x axis
axis(1,x,round(x,2),las=2)
abline(h=0,col="Red")
# Make blue segments to represent the tangents
#make green segments for y values
segments(x[1:(i-1)],y[1:(i-1)],x[2:i],rep(0,i-1),col="Blue",lwd=0.5)
segments(x[2:i],rep(0,i-1),x[2:i],y[2:i],lwd=0.5,col="Green")
# paste the root onto the last graph
arrows(x0=x[i+1],y0=y[1],x1=x[i+1],y1=y[i+1])
text(x[i+1],y[1],x[i+1])
return(list(x=x,y=y,d=d,root=x[i+1]))
par(old.par)
}
#' @return
#' @export
#'
#' @examples
#' root=mynewt(1.0,th2=c(1,1.4))$root
#' s12=100
#' s11=200
#' s22=400
#' #Test the answer in two ways
#' myfun(root)
mynewt=function(x0,f=myfun,delta=1e-12,epsilon=1e-12,th1=c(0,2*pi),th2=c(0,pi/2),parameter=expression(theta))
{
graphics.off()  # Kill all graphics windows
old.par=par()
options(digits=12)
# x0 initial value
#f the function to be zeroed
#delta is the increment in the derivative
#epsilon is how close our approximation is to zero
#th1 is the range of rotation angle for NR
#th2 is the range for rotation angle for myfun
fdash=function(x) (f(x+delta/2)-f(x-delta/2))/delta
d=1000 # initial values
i=0
x=c() # empty vectors
y=c()
x[1]=x0 # assign initial guess
y[1]=f(x[1]) # initial y value
while(d > epsilon & i<100){ # ensures that it doesnt loop too much
i=i+1
x[i+1]=x[i]-f(x[i])/fdash(x[i]) # NR step
y[i+1]=f(x[i+1]) # update y value
d=abs(y[i+1]) # update d
}
windows()
#Cut the graphical area into two
layout(matrix(1:2,nr=2,nc=1,byrow=TRUE),heights=c(3,4))
curve(f(x), xlim=th1,xlab=parameter,ylab="f",main="myfun")
abline(h=0,col="Red",lwd=2)
# plot f with no x axis  on a reduced x range
curve(f(x),xlim=th2,xaxt="n", xlab=parameter,ylab="f",main=  "Newton-Raphson Algorithm")
points(x,y,col="Red",pch=19,cex=0.5)
# Now plot the x axis
axis(1,x,round(x,2),las=2)
abline(h=0,col="Red")
# Make blue segments to represent the tangents
#make green segments for y values
segments(x[1:(i-1)],y[1:(i-1)],x[2:i],rep(0,i-1),col="Blue",lwd=0.5)
segments(x[2:i],rep(0,i-1),x[2:i],y[2:i],lwd=0.5,col="Green")
# paste the root onto the last graph
arrows(x0=x[i+1],y0=y[1],x1=x[i+1],y1=y[i+1])
text(x[i+1],y[1],x[i+1])
par(old.par)
invisible(list(x=x,y=y,d=d,root=x[i+1]))
}
mynewt()
library(ILAS2019)
ILAS2019::bullseye()
ILAS2019::mvmat()
library("ILAS2019", lib.loc="~/R/win-library/3.6")
root=mynewt(1.0,th2=c(1,1.4))$root
s12=100
s11=200
s22=400
#Test the answer in two ways
myfun(root)
library(ILAS2019)
root=mynewt(1.0,th2=c(1,1.4))$root
s12=100
s11=200
s22=400
#Test the answer in two ways
myfun(root)
library("ILAS2019", lib.loc="~/R/win-library/3.6")
remove.packages("ILAS2019", lib="~/R/win-library/3.6")
library(ILAS2019)
root=mynewt(1.0,th2=c(1,1.4))$root
s12=100
s11=200
s22=400
#Test the answer in two ways
myfun(root)
library(ILAS2019)
library(ILAS2019)
root=mynewt(1.0,th2=c(1,1.4))$root
s12=100
s11=200
s22=400
#Test the answer in two ways
myfun(root)
library("ILAS2019", lib.loc="~/R/win-library/3.6")
remove.packages("ILAS2019", lib="~/R/win-library/3.6")
root=mynewt(1.0,th2=c(1,1.4))$root
s12=100
s11=200
s22=400
#Test the answer in two ways
myfun(root)
library(ILAS2019)
mynewt(1)
library(ILAS2019)
mynewt
library(ILAS2019)
library(ILAS2019)
ILAS2019::bullseye()
ILAS2019::mynewt()
ILAS2019::bullseye(nadj=0)
ILAS2019::bullseye(nadj=1)
library(ILAS2019)
library(ILAS2019)
